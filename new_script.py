import re
import os

class ProcessFile:
    """
    FUNCTION: Provides methods for reading the POSCAR file
    """
    def __init__(self, filename = "POSCAR", output_filename = "xPOSCAR"):
        self.filename = filename
        self.output_filename = output_filename
        self.wf = open(self.output_filename, "a+")

        f = open(self.filename, "r")
        self.f_read = f.readlines()

        self.j = 0        
        self.atomic_species = self.f_read[5].split( )
        self.number_of_atoms = self.f_read[6].split( )

    def write_preamble(self):
        """
        FUNCTION: writes the first 5 lines of the POSCAR
        TODO: Change this to 5 if Bi-u modeling 
        """
        for i in range(0,5):
            self.wf.write(self.f_read[i])

    def initialize_list_of_elements(self):
        """
        FUNCTION: Returns a list of empty lists, for the purpose of filling it up
                  with coordinates of elements later on 
                  The number of empty lists is the same as the number of atom species
        """
        overall_list_of_elements = []
        for i in range(len(self.atomic_species)): # this works but i guess this can be refactored to something better
            placeholder = []
            overall_list_of_elements.append(placeholder)
        return overall_list_of_elements

    def parse_coordinates(self):
        """
        FUNCTION: Each loop creates appends a list of x, y, z coordinates corresponding to each
                  row in the POSCAR to the empty list generated by initialize_list_of_elements
                  based on the atomic species it corresponds to.
        """
        
        self.overall_list_of_coordinates = self.initialize_list_of_elements()
        c = 8 + int(self.number_of_atoms[self.j])

        for i in range(8, len(self.f_read)):
            x = self.f_read[i].split( )
            x.append(self.atomic_species[self.j])
            self.overall_list_of_coordinates[self.j].append(x)

            if i == c - 1: 
                try:
                    print("Atom read: ", self.atomic_species[self.j])
                    self.j = self.j + 1
                    c = c + int(self.number_of_atoms[self.j])
                except:
                    print("finished reading atoms")
            else:
                continue

        return self.overall_list_of_coordinates

class FixMAGMOM(ProcessFile):
    """
    FUNCTION: Arranges the POSCAR coordinates based on layer #, then based on y-axis  
    """
    def __init__(self, tot_layers = 7, surface_layers = 2, adsorbate_atoms = 0,
                 tolerance = 0):
        ProcessFile.__init__(self)
        self.overall_list_of_coordinates = self.parse_coordinates()

        self.tot_layers = int(tot_layers)
        self.surface_layers = int(surface_layers)
        self.adsorbate_atoms = int(adsorbate_atoms)
        self.tolerance = float(tolerance)

    def initialize_list_of_layers(self):
        overall_list_of_layers = []
        for i in range(len(self.atomic_species)):
            overall_list_of_layers.append([])
            for j in range(self.tot_layers):
                overall_list_of_layers[i].append([])
        return overall_list_of_layers
    
    def get_adjusted_height_range(self):
        """
        FUNCTION: Returns the approximate height of each layer
        """
        heights = []
        for height in range(8, len(self.f_read) - self.adsorbate_atoms):
            heights.append(self.f_read[height].split( )[2])

        max_height = float(max(heights))
        height_range = max_height/self.tot_layers
        adjusted_height_range = height_range - self.tolerance

        return adjusted_height_range

    def get_bulk_height(self):
        self.adjusted_height_range = self.get_adjusted_height_range()
        bulk_height = self.adjusted_height_range*(self.tot_layers-self.surface_layers)
        return bulk_height
    
    def get_number_of_bulk_atoms(self):
        """
        FUNCTION: Returns the number of transition metal bulk atoms (first element)
        """
        number_of_bulk_atoms = int(self.number_of_atoms[0]) - self.surface_layers*(int(self.number_of_atoms[0])/self.tot_layers)
        return number_of_bulk_atoms

    def rearrange_layers_by_z(self):
        """
        FUNCTION: Rearranges the layers of first element according to ascending order (z-axis)
        """
        self.overall_list_of_coordinates[0].sort(key = lambda z: float(z[2]))     

    def rearrange_layers_by_y(self):
        """
        FUNCTION: Returns a list (based on elements) of lists (based on layer # noting layer = 0 on python corresponds to layer 1 in structure)
                  of lists (of the coordinates of each atom) rearranged by y-axis and ascending layer order 
        """ 
        self.adjusted_height_range = self.get_adjusted_height_range()
        self.rearrange_layers_by_z()
        self.rearranged_overall_coordinates = []
        self.overall_list_of_layers = self.initialize_list_of_layers()
        print("atomic species", self.atomic_species)
        print("number of atoms", self.number_of_atoms)
        for i in range(len(self.atomic_species)):
            for k in range(len(self.overall_list_of_coordinates[i])):
                for j in range(self.tot_layers):
                    previous_layer_height = j*self.adjusted_height_range
                    layer_height = (j+1)*self.adjusted_height_range
                    if previous_layer_height < float(self.overall_list_of_coordinates[i][k][2]) < layer_height:
                        self.overall_list_of_layers[i][j].append(self.overall_list_of_coordinates[i][k])
                    else:
                        continue

        return self.overall_list_of_layers

### NOTE: self.overall_list_of_coordinates is a list of lists; the lists it contains corresponds to each element in the POSCAR. The lists in THOSE lists correspond to the coordinates; this isn't arranged according to y-axis yet 


class BiUModeling(FixMAGMOM):
    """
	FUNCTION: This class provides methods to adjust the POSCAR to treat a certain 
			  layer as the bulk and another layer as the surface depending on
			  the number of layers specified
	REMINDER: Put the adsorbate at the end 
	TODO: This is hardcoded for CuO (clean). Consider bond length z-components from PyMatGen and surfaces with adsorbed atoms
	"""

    def __init__(self, fix_magmom = True):
        FixMAGMOM.__init__(self)
        self.fix_magmom = fix_magmom

    def write_new_atomic_species(self):
        for i in range(len(self.atomic_species)+1):
            if i == 0: 
                self.wf.write(" %s_B" % self.atomic_species[i])
            else: 
                self.wf.write(" %s" % (self.atomic_species[i-1]))
        self.wf.write("\n")

    def write_new_number_of_atoms(self):
        number_of_bulk_atoms = int(self.get_number_of_bulk_atoms())

        for i in range(len(self.number_of_atoms)+1):
            if i == 0:
                self.wf.write(" %s" % number_of_bulk_atoms)
            elif i == 1:
                n = int(self.number_of_atoms[0]) - number_of_bulk_atoms
                self.wf.write(" %s" % n)
            else: 
                self.wf.write(" %s" % (self.number_of_atoms[i-1]))

        self.wf.write("\n")
    
    def reassign_atomic_species(self):
        """
        FUNCTION: Correctly label bulk transition metal
        """
        number_of_bulk_atoms = self.get_number_of_bulk_atoms()
        for i in range(int(number_of_bulk_atoms)):
            self.overall_list_of_coordinates[0][i][3] = self.atomic_species[0]

    def write_unsd_rearranged_layers(self):
        self.overall_list_of_layers = self.rearrange_layers_by_y()
        for i in range(len(self.atomic_species)):    
            for j in range(self.tot_layers):
                self.overall_list_of_layers[i][j].sort(key = lambda y: float(y[1]))  
                for x in range(len(self.overall_list_of_layers[i][j])):
                    self.wf.write("%s %s %s %s \n" % (self.overall_list_of_layers[i][j][x][0], 
                                                        self.overall_list_of_layers[i][j][x][1], 
                                                        self.overall_list_of_layers[i][j][x][2],
                                                        self.overall_list_of_layers[i][j][x][3])
                                 )
    def execute(self):
        # Execute from here if you don't need to use selective dynamics. 
        self.write_preamble()
        self.write_new_atomic_species()
        self.write_new_number_of_atoms()
        self.reassign_atomic_species()
        self.write_unsd_rearranged_layers()


class SelectiveDynamics(BiUModeling):
    """
    FUNCTION: Freezes based on given height 
    TODO: Base on # of desired layers to be frozen as well 
    """
    def __init__(self, height, biu_model = True):
        BiUModeling.__init__(self)
        self.height = float(height)
        self.biu_model = biu_model
    
    def define_sd_labels(self, i, j, x=None):
        if self.biu_model == False:
            if float(self.overall_list_of_coordinates[i][j][2]) < self.height:
                label = "T T T !"
            else:
                label = "F F F !"
        elif self.biu_model == True: 
            if float(self.overall_list_of_layers[i][j][x][2]) < self.height:
                label = "T T T !"
            else:
                label = "F F F !"
        return label

    def write_coordinates(self): 
        for i in range(len(self.overall_list_of_coordinates)):
            for j in range(len(self.overall_list_of_coordinates[i])):
                print(self.overall_list_of_coordinates[i][j])
                label = self.define_sd_labels(i, j)
                self.wf.write("%s %s %s %s %s \n" % (self.overall_list_of_coordinates[i][j][0],
                                                  self.overall_list_of_coordinates[i][j][1],
                                                  self.overall_list_of_coordinates[i][j][2], 
                                                  label,
                                                  self.overall_list_of_coordinates[i][j][3])
                             )

    def write_rearranged_layers(self):
        self.overall_list_of_layers = self.rearrange_layers_by_y()
        for i in range(len(self.atomic_species)):    
            for j in range(self.tot_layers):
                self.overall_list_of_layers[i][j].sort(key = lambda y: float(y[1]))  
                for x in range(len(self.overall_list_of_layers[i][j])):    
                    label = self.define_sd_labels(i, j, x)
                    self.wf.write("%s %s %s %s %s \n" % (self.overall_list_of_layers[i][j][x][0], 
                                                        self.overall_list_of_layers[i][j][x][1], 
                                                        self.overall_list_of_layers[i][j][x][2],
                                                        label,
                                                        self.overall_list_of_layers[i][j][x][3])
                                 )
    def execute(self):
        if self.biu_model == False: 
            self.write_preamble()
            self.wf.write("Selective Dynamics \n")
            for i in range(5,7):
                self.wf.write(self.f_read[i])
            self.write_coordinates()
        elif self.biu_model == True:
            self.write_preamble()
            self.write_new_atomic_species()
            self.write_new_number_of_atoms()
            self.reassign_atomic_species()
            self.wf.write("Selective Dynamics \n")
            self.write_rearranged_layers()

if __name__ == "__main__":
    fm = FixMAGMOM()
    bulk_height = fm.get_bulk_height()
    print("Bulk height = ", bulk_height)
    sd = SelectiveDynamics(bulk_height)
    sd.execute()